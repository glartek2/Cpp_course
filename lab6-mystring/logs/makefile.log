"[ 16%] Building CXX object tests/lib/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.o\n[ 33%] Linking CXX static library ../../../lib/libgtest.a\n[ 33%] Built target gtest\n[ 50%] Building CXX object tests/lib/googletest/CMakeFiles/gtest_main.dir/src/gtest_main.cc.o\n[ 66%] Linking CXX static library ../../../lib/libgtest_main.a\n[ 66%] Built target gtest_main\n[ 83%] Building CXX object tests/CMakeFiles/tests.dir/myStringTests.cpp.o\nIn file included from /tmp/tmpacl04vps/student/tests/myStringTests.cpp:10:\n/tmp/tmpacl04vps/student/tests/../mystring.h: In member function \u2018const char& MyString::const_iterator::operator*() const\u2019:\n/tmp/tmpacl04vps/student/tests/../mystring.h:242:36: error: returning reference to temporary [-Werror=return-local-addr]\n  242 |         return (*myString)[position];\n      |                ~~~~~~~~~~~~~~~~~~~~^\nIn file included from /usr/include/c++/13/vector:62,\n                 from /tmp/tmpacl04vps/student/tests/myStringTests.cpp:1:\n/usr/include/c++/13/bits/stl_algobase.h: In instantiation of \u2018constexpr _Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = MyString::iterator; _Predicate = __gnu_cxx::__ops::_Iter_pred<MyString::trim()::<lambda(char)> >]\u2019:\n/usr/include/c++/13/bits/stl_algo.h:3923:28:   required from \u2018constexpr _IIter std::find_if(_IIter, _IIter, _Predicate) [with _IIter = MyString::iterator; _Predicate = MyString::trim()::<lambda(char)>]\u2019\n/tmp/tmpacl04vps/student/tests/../mystring.h:439:30:   required from here\n/usr/include/c++/13/bits/stl_algobase.h:2118:48: error: no matching function for call to \u2018__iterator_category(MyString::iterator&)\u2019\n 2118 |                        std::__iterator_category(__first));\n      |                        ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\nIn file included from /usr/include/c++/13/bits/stl_algobase.h:65:\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: note: candidate: \u2018template<class _Iter> constexpr typename std::iterator_traits< <template-parameter-1-1> >::iterator_category std::__iterator_category(const _Iter&)\u2019\n  239 |     __iterator_category(const _Iter&)\n      |     ^~~~~~~~~~~~~~~~~~~\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_iterator_base_types.h: In substitution of \u2018template<class _Iter> constexpr typename std::iterator_traits< <template-parameter-1-1> >::iterator_category std::__iterator_category(const _Iter&) [with _Iter = MyString::iterator]\u2019:\n/usr/include/c++/13/bits/stl_algobase.h:2118:34:   required from \u2018constexpr _Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = MyString::iterator; _Predicate = __gnu_cxx::__ops::_Iter_pred<MyString::trim()::<lambda(char)> >]\u2019\n/usr/include/c++/13/bits/stl_algo.h:3923:28:   required from \u2018constexpr _IIter std::find_if(_IIter, _IIter, _Predicate) [with _IIter = MyString::iterator; _Predicate = MyString::trim()::<lambda(char)>]\u2019\n/tmp/tmpacl04vps/student/tests/../mystring.h:439:30:   required from here\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: error: no type named \u2018iterator_category\u2019 in \u2018struct std::iterator_traits<MyString::iterator>\u2019\n/usr/include/c++/13/bits/stl_algobase.h: In instantiation of \u2018constexpr _Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = MyString::reverse_iterator; _Predicate = __gnu_cxx::__ops::_Iter_pred<MyString::trim()::<lambda(char)> >]\u2019:\n/usr/include/c++/13/bits/stl_algo.h:3923:28:   required from \u2018constexpr _IIter std::find_if(_IIter, _IIter, _Predicate) [with _IIter = MyString::reverse_iterator; _Predicate = MyString::trim()::<lambda(char)>]\u2019\n/tmp/tmpacl04vps/student/tests/../mystring.h:440:31:   required from here\n/usr/include/c++/13/bits/stl_algobase.h:2118:48: error: no matching function for call to \u2018__iterator_category(MyString::reverse_iterator&)\u2019\n 2118 |                        std::__iterator_category(__first));\n      |                        ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: note: candidate: \u2018template<class _Iter> constexpr typename std::iterator_traits< <template-parameter-1-1> >::iterator_category std::__iterator_category(const _Iter&)\u2019\n  239 |     __iterator_category(const _Iter&)\n      |     ^~~~~~~~~~~~~~~~~~~\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_iterator_base_types.h: In substitution of \u2018template<class _Iter> constexpr typename std::iterator_traits< <template-parameter-1-1> >::iterator_category std::__iterator_category(const _Iter&) [with _Iter = MyString::reverse_iterator]\u2019:\n/usr/include/c++/13/bits/stl_algobase.h:2118:34:   required from \u2018constexpr _Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = MyString::reverse_iterator; _Predicate = __gnu_cxx::__ops::_Iter_pred<MyString::trim()::<lambda(char)> >]\u2019\n/usr/include/c++/13/bits/stl_algo.h:3923:28:   required from \u2018constexpr _IIter std::find_if(_IIter, _IIter, _Predicate) [with _IIter = MyString::reverse_iterator; _Predicate = MyString::trim()::<lambda(char)>]\u2019\n/tmp/tmpacl04vps/student/tests/../mystring.h:440:31:   required from here\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: error: no type named \u2018iterator_category\u2019 in \u2018struct std::iterator_traits<MyString::reverse_iterator>\u2019\nIn file included from /usr/include/c++/13/bits/refwrap.h:39,\n                 from /usr/include/c++/13/vector:68:\n/usr/include/c++/13/bits/stl_function.h: In instantiation of \u2018constexpr bool std::less<_Tp>::operator()(const _Tp&, const _Tp&) const [with _Tp = MyString]\u2019:\n/usr/include/c++/13/bits/stl_map.h:511:32:   required from \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key, _Tp, _Compare, _Alloc>::operator[](const key_type&) [with _Key = MyString; _Tp = long unsigned int; _Compare = std::less<MyString>; _Alloc = std::allocator<std::pair<const MyString, long unsigned int> >; mapped_type = long unsigned int; key_type = MyString]\u2019\n/tmp/tmpacl04vps/student/tests/../mystring.h:501:32:   required from here\n/usr/include/c++/13/bits/stl_function.h:408:20: error: no match for \u2018operator<\u2019 (operand types are \u2018const MyString\u2019 and \u2018const MyString\u2019)\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\nIn file included from /usr/include/c++/13/bits/stl_algobase.h:67:\n/usr/include/c++/13/bits/stl_iterator.h:583:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR>  requires  three_way_comparable_with<_IteratorR, _IteratorL, std::partial_ordering> constexpr std::compare_three_way_result_t<_IteratorL, _IteratorR> std::operator<=>(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorR>&)\u2019 (reversed)\n  583 |     operator<=>(const reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:583:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_function.h:408:20: note:   \u2018const MyString\u2019 is not derived from \u2018const std::reverse_iterator<_IteratorL>\u2019\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1690:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR>  requires  three_way_comparable_with<_IteratorR, _IteratorL, std::partial_ordering> constexpr std::compare_three_way_result_t<_IteratorL, _IteratorR> std::operator<=>(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)\u2019 (reversed)\n 1690 |     operator<=>(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1690:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_function.h:408:20: note:   \u2018const MyString\u2019 is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\nIn file included from /usr/include/c++/13/bits/stl_algobase.h:64:\n/usr/include/c++/13/bits/stl_pair.h:819:5: note: candidate: \u2018template<class _T1, class _T2> constexpr std::common_comparison_category_t<decltype (std::__detail::__synth3way(declval<_T1&>(), declval<_T1&>())), decltype (std::__detail::__synth3way(declval<_T2&>(), declval<_T2&>()))> std::operator<=>(const pair<_T1, _T2>&, const pair<_T1, _T2>&)\u2019 (rewritten)\n  819 |     operator<=>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_pair.h:819:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_function.h:408:20: note:   \u2018const MyString\u2019 is not derived from \u2018const std::pair<_T1, _T2>\u2019\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\n/usr/include/c++/13/bits/stl_iterator.h:601:5: note: candidate: \u2018template<class _Iterator>  requires  three_way_comparable<_Iterator, std::partial_ordering> constexpr std::compare_three_way_result_t<_Iterator, _Iterator> std::operator<=>(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorL>&)\u2019 (rewritten)\n  601 |     operator<=>(const reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:601:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_function.h:408:20: note:   \u2018const MyString\u2019 is not derived from \u2018const std::reverse_iterator<_IteratorL>\u2019\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1756:5: note: candidate: \u2018template<class _Iterator>  requires  three_way_comparable<_Iterator, std::partial_ordering> constexpr std::compare_three_way_result_t<_Iterator, _Iterator> std::operator<=>(const move_iterator<_IteratorL>&, const move_iterator<_IteratorL>&)\u2019 (rewritten)\n 1756 |     operator<=>(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1756:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_function.h:408:20: note:   \u2018const MyString\u2019 is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\nIn file included from /usr/include/c++/13/vector:66:\n/usr/include/c++/13/bits/stl_vector.h:2056:5: note: candidate: \u2018template<class _Tp, class _Alloc> constexpr std::__detail::__synth3way_t<_T1> std::operator<=>(const vector<_Tp, _Alloc>&, const vector<_Tp, _Alloc>&)\u2019 (rewritten)\n 2056 |     operator<=>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_vector.h:2056:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_function.h:408:20: note:   \u2018const MyString\u2019 is not derived from \u2018const std::vector<_Tp, _Alloc>\u2019\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\n/usr/include/c++/13/bits/stl_iterator.h:550:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr bool std::operator<(const reverse_iterator<_IteratorL>&, const reverse_iterator<_IteratorR>&) requires requires{{std::operator<::__x->base() > std::operator<::__y->base()} -> decltype(auto) [requires std::convertible_to<<placeholder>, bool>];}\u2019\n  550 |     operator<(const reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:550:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_function.h:408:20: note:   \u2018const MyString\u2019 is not derived from \u2018const std::reverse_iterator<_IteratorL>\u2019\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1705:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr bool std::operator<(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&) requires requires{{std::operator<::__x->base() < std::operator<::__y->base()} -> decltype(auto) [requires std::convertible_to<<placeholder>, bool>];}\u2019\n 1705 |     operator<(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/13/bits/stl_iterator.h:1705:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_function.h:408:20: note:   \u2018const MyString\u2019 is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n  408 |       { return __x < __y; }\n      |                ~~~~^~~~~\nIn file included from /usr/include/c++/13/string:54,\n                 from /usr/include/c++/13/bits/locale_classes.h:40,\n                 from /usr/include/c++/13/bits/ios_base.h:41,\n                 from /usr/include/c++/13/iomanip:42,\n                 from /tmp/tmpacl04vps/student/tests/lib/googletest/include/gtest/gtest.h:54,\n                 from /tmp/tmpacl04vps/student/tests/myStringTests.cpp:7:\n/usr/include/c++/13/bits/basic_string.h: In instantiation of \u2018static constexpr void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, _Iterator, _Iterator) [with _Iterator = MyString*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019:\n/usr/include/c++/13/bits/basic_string.tcc:243:21:   required from \u2018constexpr void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = MyString*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n/usr/include/c++/13/bits/basic_string.h:753:16:   required from \u2018constexpr std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&) [with _InputIterator = MyString*; <template-parameter-2-2> = void; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n/tmp/tmpacl04vps/student/tests/../mystring.h:442:56:   required from here\n/usr/include/c++/13/bits/basic_string.h:451:32: error: no matching function for call to \u2018std::char_traits<char>::assign(char&, MyString&)\u2019\n  451 |             traits_type::assign(*__p, *__k1); // These types are off.\n      |             ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~\nIn file included from /usr/include/c++/13/string:42:\n/usr/include/c++/13/bits/char_traits.h:361:7: note: candidate: \u2018static constexpr void std::char_traits<char>::assign(char_type&, const char_type&)\u2019\n  361 |       assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~\n/usr/include/c++/13/bits/char_traits.h:361:48: note:   no known conversion for argument 2 from \u2018MyString\u2019 to \u2018const std::char_traits<char>::char_type&\u2019 {aka \u2018const char&\u2019}\n  361 |       assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      |                               ~~~~~~~~~~~~~~~~~^~~~\n/usr/include/c++/13/bits/char_traits.h:449:7: note: candidate: \u2018static constexpr std::char_traits<char>::char_type* std::char_traits<char>::assign(char_type*, std::size_t, char_type)\u2019\n  449 |       assign(char_type* __s, size_t __n, char_type __a)\n      |       ^~~~~~\n/usr/include/c++/13/bits/char_traits.h:449:7: note:   candidate expects 3 arguments, 2 provided\nIn file included from /usr/include/c++/13/algorithm:61,\n                 from /tmp/tmpacl04vps/student/tests/myStringTests.cpp:2:\n/usr/include/c++/13/bits/stl_algo.h: In instantiation of \u2018constexpr _InputIterator std::__find_if_not(_InputIterator, _InputIterator, _Predicate) [with _InputIterator = MyString::const_iterator; _Predicate = __gnu_cxx::__ops::_Iter_pred<function<bool(char)> >]\u2019:\n/usr/include/c++/13/bits/stl_algo.h:519:32:   required from \u2018constexpr _IIter std::find_if_not(_IIter, _IIter, _Predicate) [with _IIter = MyString::const_iterator; _Predicate = function<bool(char)>]\u2019\n/usr/include/c++/13/bits/stl_algo.h:459:40:   required from \u2018constexpr bool std::all_of(_IIter, _IIter, _Predicate) [with _IIter = MyString::const_iterator; _Predicate = function<bool(char)>]\u2019\n/tmp/tmpacl04vps/student/tests/../mystring.h:463:23:   required from here\n/usr/include/c++/13/bits/stl_algo.h:114:53: error: no matching function for call to \u2018__iterator_category(MyString::const_iterator&)\u2019\n  114 |                             std::__iterator_category(__first));\n      |                             ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: note: candidate: \u2018template<class _Iter> constexpr typename std::iterator_traits< <template-parameter-1-1> >::iterator_category std::__iterator_category(const _Iter&)\u2019\n  239 |     __iterator_category(const _Iter&)\n      |     ^~~~~~~~~~~~~~~~~~~\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/stl_iterator_base_types.h: In substitution of \u2018template<class _Iter> constexpr typename std::iterator_traits< <template-parameter-1-1> >::iterator_category std::__iterator_category(const _Iter&) [with _Iter = MyString::const_iterator]\u2019:\n/usr/include/c++/13/bits/stl_algo.h:114:32:   required from \u2018constexpr _InputIterator std::__find_if_not(_InputIterator, _InputIterator, _Predicate) [with _InputIterator = MyString::const_iterator; _Predicate = __gnu_cxx::__ops::_Iter_pred<function<bool(char)> >]\u2019\n/usr/include/c++/13/bits/stl_algo.h:519:32:   required from \u2018constexpr _IIter std::find_if_not(_IIter, _IIter, _Predicate) [with _IIter = MyString::const_iterator; _Predicate = function<bool(char)>]\u2019\n/usr/include/c++/13/bits/stl_algo.h:459:40:   required from \u2018constexpr bool std::all_of(_IIter, _IIter, _Predicate) [with _IIter = MyString::const_iterator; _Predicate = function<bool(char)>]\u2019\n/tmp/tmpacl04vps/student/tests/../mystring.h:463:23:   required from here\n/usr/include/c++/13/bits/stl_iterator_base_types.h:239:5: error: no type named \u2018iterator_category\u2019 in \u2018struct std::iterator_traits<MyString::const_iterator>\u2019\ncc1plus: all warnings being treated as errors\nmake[3]: *** [tests/CMakeFiles/tests.dir/build.make:76: tests/CMakeFiles/tests.dir/myStringTests.cpp.o] Error 1\nmake[2]: *** [CMakeFiles/Makefile2:345: tests/CMakeFiles/tests.dir/all] Error 2\nmake[1]: *** [CMakeFiles/Makefile2:352: tests/CMakeFiles/tests.dir/rule] Error 2\nmake: *** [Makefile:260: tests] Error 2\n"